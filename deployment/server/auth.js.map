{"version":3,"sources":["../../server/auth.js"],"names":["require","load","auth","use","json","req","res","next","post","objectManager","User_AccountName","body","toLowerCase","User_AccountPassword","then","getObjectList","arr_Users","length","status","error","a_User","compare","err","User_AccountPasswordIsCorrect","codeFoundriesInjected","user","token","encode","user_id","id","process","env","JWT_SECRET","cookie","httpOnly","success","UserToken2","catch","reason","Promise","reject","resolve","hash","accountNameIsValidEmail","User_Email","Math","random","toString","substring","User_DisplayName","add","getOneObject","expires","Date"],"mappings":"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","file":"auth.js","sourcesContent":["// @flow weak\n\nimport bcrypt from 'bcrypt'\nimport bodyParser from 'body-parser'\nimport express from 'express'\nimport jwt from 'jwt-simple'\n\nimport authExtensions from '../configuration/server/authExtensions'\nimport delayPromise from '../scripts/delayPromise'\nimport getNewUser from '../configuration/graphql/model/getNewUser'\nimport logServerRequest from './logServerRequest'\nimport ObjectManager from '../graphql/ObjectManager'\nimport { requestLoggerAuth } from '../configuration/server/requestLoggers'\nimport { validateEmail } from '../scripts/validation'\n\n\n// Read environment\nrequire( 'dotenv' ).load()\n\n\nconst auth = express()\n\nauth.use( bodyParser.json() )\nauth.use( ( req, res, next ) => logServerRequest( req, res, next, requestLoggerAuth ) )\n\nauth.post( '/login', ( req, res ) => {\n\n  const objectManager = new ObjectManager()\n\n  let User_AccountName = req.body.User_AccountName.toLowerCase()\n  let User_AccountPassword = req.body.User_AccountPassword\n\n  delayPromise( 1000 ) // Wait for a second to slow down a possible potential force attack\n    .then( () => objectManager.getObjectList( 'User', { User_AccountName: User_AccountName } ) )\n    .then( ( arr_Users ) => {\n      if( arr_Users.length == 0 )\n        res.status( 401 ).json( { error: 'Incorrect user' } )\n      else {\n        const a_User = arr_Users[ 0 ]\n\n        bcrypt.compare( User_AccountPassword, a_User.User_AccountPassword, function ( err, User_AccountPasswordIsCorrect ) {\n          if( User_AccountPasswordIsCorrect ) {\n            res.codeFoundriesInjected = { user: a_User }\n\n            // User has authenticated correctly thus we create a JWT token\n            var token = jwt.encode( { user_id: a_User.id }, process.env.JWT_SECRET )\n\n            res.cookie( 'UserToken1', token, { httpOnly: true } )\n            res.json( { success: true, UserToken2: a_User.UserToken2 } )\n          } else\n            res.status( 401 ).json( { error: 'Incorrect password' } )\n        } )\n      }\n    } )\n    .catch( ( reason ) => { res.status( 401 ).json( { error: reason } ) } )\n} )\n\nauth.post( '/createuser', ( req, res ) => {\n  const objectManager = new ObjectManager()\n\n  let User_AccountName = req.body.User_AccountName.toLowerCase()\n  let User_AccountPassword = req.body.User_AccountPassword\n  objectManager.getObjectList( 'User', {\n      User_AccountName: User_AccountName\n    } )\n    .then( ( arr_Users ) => {\n      if( arr_Users.length > 0 )\n        return Promise.reject( \"User account already exists\" )\n      else\n        return new Promise( ( resolve ) => { bcrypt.hash( User_AccountPassword, 8, ( err, User_AccountPassword ) => resolve( User_AccountPassword ) ) } )\n          .then( ( User_AccountPassword ) => {\n            // If account name looks like email address, use it as email\n            const accountNameIsValidEmail = validateEmail( User_AccountName )\n            const User_Email = accountNameIsValidEmail ? User_AccountName : ''\n\n            const a_User = Object.assign( getNewUser(), {\n              UserToken2: Math.random().toString( 36 ).substring( 2 ) + Math.random().toString( 36 ).substring( 2 ),\n              User_AccountName: User_AccountName,\n              User_AccountPassword: User_AccountPassword,\n              User_DisplayName: User_AccountName,\n              User_Email: User_Email,\n            } )\n            return objectManager.add( 'User', a_User )\n          } )\n    } )\n    .then( ( user_id ) => objectManager.getOneObject( 'User', { id: user_id } ) )\n    .then( ( a_User ) => {\n      res.codeFoundriesInjected = { user: a_User }\n\n      // User has been created thus we create a JWT token\n      var token = jwt.encode( { user_id: a_User.id }, process.env.JWT_SECRET )\n\n      res.cookie( 'UserToken1', token, { httpOnly: true } )\n      res.json( { success: true } )\n    } )\n    .catch( ( reason ) => { res.status( 401 ).json( { error: \"\" + reason } ) } )\n} )\n\nauth.post( '/logout', ( req, res ) => {\n  res.cookie( 'UserToken1', '', { httpOnly: true, expires: new Date( 1 ) } )\n  res.json( { success: true } )\n} )\n\n\n// Add extensions - custom configurations\nauthExtensions( auth )\n\n\nexport default auth\n"]}