{"version":3,"sources":["../../../../units/urb-persister-waterline/graphql/PersisterWaterline.js"],"names":["Uuid_Null","PersisterWaterline","stores","entityName","filter","store","getStore","arr_Indexes","map","objectInStore","index","filterMatched","filterField","push","arr_Objects","ObjectType","filters","findObjects","Promise","resolve","arr_arr_Objects","fields","newObject","newFields","id","an_Object","fieldName","indexToDelete","findIndexes","splice","transports","Console","str","v1","id1","id2","tableName","tableSchema","reject","runAsPartOfSetupDatabase","cb"],"mappings":"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","file":"PersisterWaterline.js","sourcesContent":["// @flow weak\n\nimport uuid from 'node-uuid'\nimport winston from 'winston'\n\n\n// Work in progress, right now just in-memory storage\n// Tracking issue: https://github.com/codefoundries/UniversalRelayBoilerplate/issues/222\n\nconst Uuid_Null = '00000000-0000-0000-0000-000000000000'\n\n\nexport default class PersisterWaterline {\n\n  constructor() {\n\n    this.stores = {}\n  }\n\n  getStore( entityName: string ) {\n\n    if( entityName in this.stores )\n      return this.stores[ entityName ]\n    else\n      return( this.stores[ entityName ] = [] )\n  }\n\n  findIndexes( entityName: string, filter: object ) {\n\n    const store = this.getStore( entityName )\n    const arr_Indexes = []\n\n    store.map( ( objectInStore, index ) => {\n      let filterMatched = true\n      for( let filterField in filter )\n        if( objectInStore[ filterField ] != filter[ filterField ] ) {\n          filterMatched = false\n          break\n        }\n\n      if( filterMatched )\n        arr_Indexes.push( index )\n    } )\n\n    return arr_Indexes\n  }\n\n  findObjects( entityName: string, filter: object ) {\n\n    const store = this.getStore( entityName )\n    const arr_Objects = []\n\n    store.map( ( objectInStore ) => {\n      let filterMatched = true\n      for( let filterField in filter )\n        if( objectInStore[ filterField ] != filter[ filterField ] ) {\n          filterMatched = false\n          break\n        }\n\n      if( filterMatched )\n        arr_Objects.push( objectInStore )\n    } )\n\n    return arr_Objects\n  }\n\n  getOneObject( entityName: string, ObjectType: any, filters: Array < any > ): Promise {\n\n    const arr_Objects = filters.map( filter => this.findObjects( entityName, filter )[ 0 ] )\n    return Promise.resolve( arr_Objects )\n  }\n\n  getObjectList( entityName: string, ObjectType: any, filters: Array < any > ): Promise {\n\n    const arr_arr_Objects = filters.map( filter => this.findObjects( entityName, filter ) )\n    return Promise.resolve( arr_arr_Objects )\n  }\n\n  add( entityName: string, fields: any, ObjectType: any ) {\n\n    const store = this.getStore( entityName )\n    const newObject = new ObjectType( fields )\n\n    store.push( newObject )\n\n    return Promise.resolve()\n  }\n\n  update( entityName: string, fields: any ): Promise {\n\n    // Only use the ID to find the record to delete\n    const newFields = {}\n    newFields.id = fields.id\n\n    const an_Object = this.findObjects( entityName, newFields )[ 0 ]\n\n    for( let fieldName in fields )\n      an_Object[ fieldName ] = fields[ fieldName ]\n\n    return Promise.resolve()\n  }\n\n  remove( entityName: string, fields: any ): Promise {\n\n    const store = this.getStore( entityName )\n\n    const indexToDelete = this.findIndexes( entityName, fields )[ 0 ]\n    store.splice( indexToDelete, 1 )\n\n    return Promise.resolve()\n  }\n\n  createLogger() {\n\n    return new( winston.transports.Console )()\n  }\n\n  uuidFromString( str: string ): string {\n\n    return str\n  }\n\n  uuidRandom(): string {\n\n    return uuid.v1()\n  }\n\n  uuidNull() {\n\n    return Uuid_Null\n  }\n\n  uuidNullAsString() {\n\n    return Uuid_Null\n  }\n\n  uuidToString( id: any ) {\n\n    // ids are always strings anyway\n    return id\n  }\n\n  uuidEquals( id1: any, id2: any ): boolean {\n\n    return id1 == id2\n  }\n\n  addTableSchema( tableName: string, tableSchema: object ): void {\n\n    // Nothing to do, it's all in memory\n  }\n\n  confirmHealth(): Promise < > {\n\n    return new Promise( ( resolve, reject ) => {\n      resolve()\n    } )\n  }\n\n  initialize( runAsPartOfSetupDatabase: boolean, cb: Function ): void {\n\n    // Nothing to do, it's all in memory\n    cb()\n  }\n}\n"]}